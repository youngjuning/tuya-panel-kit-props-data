"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var types_1 = require("@babel/types");
var generator_1 = require("@babel/generator");
var comment_1 = require("./comment");
function generateType(typeAnnotation) {
    if (!typeAnnotation) {
        return '';
    }
    return generator_1.default(typeAnnotation).code
        .slice(2)
        .replace(/\n/g, '');
}
function parseTsInterfaceDeclaration(targetInterface) {
    var result = targetInterface.body.body.map(function (node) {
        if (!(types_1.isTSPropertySignature(node) || types_1.isTSMethodSignature(node))) {
            return null;
        }
        var optional = node.optional, key = node.key, typeAnnotation = node.typeAnnotation, leadingComments = node.leadingComments;
        if (!types_1.isIdentifier(key)) {
            return null;
        }
        var meta;
        if (Array.isArray(leadingComments) && leadingComments.length > 0) {
            meta = comment_1.mergeFieldMeta(leadingComments.map(function (o) { return comment_1.parserComment(o.value); }));
        }
        var result = {
            optional: optional ? 'true' : 'false',
            name: key.name,
            types: generateType(typeAnnotation)
        };
        if (meta) {
            result.meta = meta;
        }
        return result;
    });
    return result.filter(function (o) { return !!o; });
}
exports.parseTsInterfaceDeclaration = parseTsInterfaceDeclaration;
function parseClassDeclaration(target) {
    var result = target.body.body.map(function (node) {
        if (!types_1.isClassProperty(node)) {
            return null;
        }
        var optional = node.optional, key = node.key, typeAnnotation = node.typeAnnotation, leadingComments = node.leadingComments;
        if (!types_1.isIdentifier(key)) {
            return null;
        }
        var meta;
        if (Array.isArray(leadingComments) && leadingComments.length > 0) {
            meta = comment_1.mergeFieldMeta(leadingComments.map(function (o) { return comment_1.parserComment(o.value); }));
        }
        var result = {
            optional: optional ? 'true' : 'false',
            name: key.name,
            types: generateType(typeAnnotation)
        };
        if (meta) {
            result.meta = meta;
        }
        return result;
    });
    return result.filter(function (o) { return !!o; });
}
exports.parseClassDeclaration = parseClassDeclaration;
