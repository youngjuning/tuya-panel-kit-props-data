"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var babelParser = require("@babel/parser");
var types_1 = require("@babel/types");
var fs = require("fs");
var parser_1 = require("./parser");
function parse(filePath, name) {
    var ast = babelParser.parse(fs.readFileSync(filePath).toString(), {
        sourceType: 'module',
        plugins: ['typescript', 'classProperties']
    });
    for (var _i = 0, _a = ast.program.body; _i < _a.length; _i++) {
        var node = _a[_i];
        if (types_1.isExportNamedDeclaration(node)) {
            node = node.declaration;
        }
        if (types_1.isTSInterfaceDeclaration(node) && node.id.name === name) {
            return parser_1.parseTsInterfaceDeclaration(node);
        }
        if (types_1.isClassDeclaration(node) && node.id.name === name) {
            return parser_1.parseClassDeclaration(node);
        }
    }
    return null;
}
exports.parse = parse;
function parseAllInterface(filePath) {
    var ast = babelParser.parse(fs.readFileSync(filePath).toString(), {
        sourceType: 'module',
        plugins: ['typescript', 'classProperties']
    });
    var result = {};
    for (var _i = 0, _a = ast.program.body; _i < _a.length; _i++) {
        var node = _a[_i];
        if (types_1.isExportNamedDeclaration(node)) {
            node = node.declaration;
        }
        if (types_1.isTSInterfaceDeclaration(node)) {
            result[node.id.name] = parser_1.parseTsInterfaceDeclaration(node);
        }
    }
    return result;
}
exports.parseAllInterface = parseAllInterface;
function getFieldMeta(field, language) {
    var meta = field.meta, name = field.name, optional = field.optional, types = field.types;
    var baseInfo = {
        name: name,
        optional: optional,
        types: types
    };
    if (!meta) {
        return baseInfo;
    }
    return Object.assign(baseInfo, meta.base, meta.i18n[language]);
}
exports.getFieldMeta = getFieldMeta;
